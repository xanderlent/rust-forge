<!DOCTYPE html>
<!-- Page last generated 2019-03-06 13:48:16 +0000 -->
<html lang="en">
  <head>
    <meta charset="utf-8">
    <title>Profiling queries</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="keywords" content="Rust, Rust programming language, rustlang, rust-lang, Mozilla Rust">
    <meta name="description" content="A systems programming language that runs blazingly fast, prevents segfaults, and guarantees thread safety.">
    <link rel="stylesheet" href="/css/bootstrap.css">
    <link rel="stylesheet" href="/css/style.css">
    <link rel="stylesheet" href="/css/forge.css">
    <link rel="stylesheet" href="/rust-forge/css/bootstrap.css">
    <link rel="stylesheet" href="/rust-forge/css/style.css">
    <link rel="stylesheet" href="/rust-forge/css/forge.css">
  </head>

  <body class="container">

    <header>

    <ul class="row menu">
      <li class="col-xs-12 col-md-2">
        <a href="index.html">
	  <!-- FIXME: absolute urls -->
          <img class="img-responsive" src="https://www.rust-lang.org/logos/rust-logo-blk.svg" onerror="this.src='https://www.rust-lang.org/logos/rust-logo-256x256-blk.png'" height="128" width="128" alt="Rust logo" />
        </a>
      </li>
      <li class="col-xs-12 col-md-6 menu">
	<h1>Rust Forge</h1>
      </li>
    </ul>
    </header>

    <div class="content"><h1 id="profiling-queries">Profiling Queries</h1>

<p>In an effort to support <em>incremental compilation</em>, the latest design of
the Rust compiler consists of a <em>query-based</em> model.</p>

<p>The details of this model are (currently) outside the scope of this
document, however, we explain
<a href="#background">some background of this model</a>, in an effort to explain
how we profile its performance. We intend this profiling effort to address
<a href="https://github.com/rust-lang/rust/issues/42678">issue 42678</a>.</p>

<h2 id="quick-start">Quick Start</h2>

<h3 id="0-enable-debug-assertions">0. Enable debug assertions</h3>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>./configure --enable-debug-assertions
</code></pre></div></div>

<h3 id="1-compile-rustc">1. Compile <code class="highlighter-rouge">rustc</code></h3>
<p>Compile the compiler, up to at least stage 1:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>python x.py --stage 1
</code></pre></div></div>

<h3 id="2-run-rustc-with-flags">2. Run <code class="highlighter-rouge">rustc</code>, with flags</h3>
<p>Run the compiler on a source file, supplying two additional debugging flags with <code class="highlighter-rouge">-Z</code>:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>rustc -Z profile-queries -Z incremental=cache foo.rs
</code></pre></div></div>

<p>Regarding the two additional parameters:</p>

<ul>
  <li><code class="highlighter-rouge">-Z profile-queries</code> tells the compiler to run a separate thread
that profiles the queries made by the main compiler thread(s).</li>
  <li><code class="highlighter-rouge">-Z incremental=cache</code> tells the compiler to “cache” various files
that describe the compilation dependencies, in the subdirectory
<code class="highlighter-rouge">cache</code>.</li>
</ul>

<p>This command will generate the following files:</p>

<ul>
  <li><code class="highlighter-rouge">profile_queries.html</code> consists of an HTML-based representation of
the <a href="#trace-of-queries">trace of queries</a>.</li>
  <li><code class="highlighter-rouge">profile_queries.counts.txt</code> consists of a histogram, where each histogram “bucket” is a query provider.</li>
</ul>

<h3 id="3-run-rustc-with--z-time-passes">3. Run <code class="highlighter-rouge">rustc</code>, with <code class="highlighter-rouge">-Z time-passes</code>:</h3>

<ul>
  <li>This additional flag will add all timed passes to the output files
mentioned above, in step 2.  As described below, these passes appear
visually distinct from the queries in the HTML output (they
currently appear as green boxes, via CSS).</li>
</ul>

<h3 id="4-inspect-the-output">4. Inspect the output</h3>

<ul>
  <li>4(a). Open the HTML file (<code class="highlighter-rouge">profile_queries.html</code>) with a browser.
See <a href="#interpret-the-html-output">this section</a> for an explanation of
this file.</li>
  <li>4(b). Open the data file (<code class="highlighter-rouge">profile_queries.counts.txt</code>) with a text
editor, or spreadsheet.  See <a href="#interpret-the-data-output">this
section</a> for an explanation of this
file.</li>
</ul>

<h2 id="interpret-the-html-output">Interpret the HTML Output</h2>

<h3 id="example-0">Example 0</h3>

<p>The following image gives some example output, from tracing the
queries of <code class="highlighter-rouge">hello_world.rs</code> (a single <code class="highlighter-rouge">main</code> function, that prints
<code class="highlighter-rouge">"hello world"</code> via the macro <code class="highlighter-rouge">println!</code>).  This image only shows a
short prefix of the total output; the <em>actual</em> output is much longer.</p>

<p><img src="profile-queries/example0.png" alt="" /></p>

<p><a href="profile-queries/example0/profile_queries.html">Full HTML output</a></p>

<h3 id="example-0-explanation">Example 0 explanation</h3>

<p>The trace of the queries has a formal structure; see
<a href="#trace-of-queries">Trace of Queries</a> for details.</p>

<p>We style this formal structure as follows:</p>

<ul>
  <li><strong>Timed passes:</strong> Green boxes, when present (via <code class="highlighter-rouge">-Z time-passes</code>), represent <em>timed
passes</em> in the compiler.  In future versions, these passes may be
replaced by queries, explained below.</li>
  <li><strong>Labels:</strong> Some green and red boxes are labeled with text. Where they are
present, the labels give the following information:
    <ul>
      <li>The <a href="#queries">query’s <em>provider</em></a>, sans its <em>key</em> and its <em>result</em>,
which are often too long to include in these labels.</li>
      <li>The <em>duration</em> of the provider, as a fraction of the total time
(for the entire trace). This fraction includes the query’s
entire extent (that is, the sum total of all of its
sub-queries).</li>
    </ul>
  </li>
  <li><strong>Query hits:</strong> Blue dots represent query hits.  They consist of leaves in the
trace’s tree. (CSS class: <code class="highlighter-rouge">hit</code>).</li>
  <li><strong>Query misses:</strong> Red boxes represent query misses. They consist of internal nodes in
the trace’s tree. (CSS class: <code class="highlighter-rouge">miss</code>).</li>
  <li><strong>Nesting structure:</strong> Many red boxes contain <em>nested boxes and
dots</em>.  This nesting structure reflects that some providers <em>depend
on</em> results from other providers, which consist of their nested
children.</li>
  <li>Some red boxes are <em>labeled</em> with text, and have highlighted borders
(light red, and bolded).  (See <a href="#heuristics">heuristics</a> for
details).</li>
</ul>

<h2 id="heuristics">Heuristics</h2>

<p>Heuristics-based CSS Classes:</p>

<ul>
  <li>
    <p><code class="highlighter-rouge">important</code> – Trace nodes are <code class="highlighter-rouge">important</code> if they have an extent of
6 (or more), <em>or</em> they have a duration fraction of one percent (or
more).  These numbers are simple heuristics (currently hard-coded,
but easy to modify).  Important nodes are styled with textual
labels, and highlighted borders (light red, and bolded).</p>
  </li>
  <li>
    <p><code class="highlighter-rouge">frac-50</code>, <code class="highlighter-rouge">-40</code>, … – Trace nodes whose total duration (self and
children) take a large fraction of the total duration, at or above
50%, 40%, and so on.  We style nodes these with larger font and
padding.</p>
  </li>
</ul>

<h2 id="interpret-the-data-output">Interpret the Data Output</h2>

<p>The file <code class="highlighter-rouge">profile_queries.counts.txt</code> contains a table of information
about the queries, organized around their providers.</p>

<p>For each provider (or timed pass, when <code class="highlighter-rouge">-Z time-passes</code> is present), we produce:</p>

<ul>
  <li>
    <p>A total <strong>count</strong> — the total number of times this provider was
queried</p>
  </li>
  <li>
    <p>A total <strong>duration</strong> — the total number of seconds spent running
this provider, <em>including</em> all providers it may depend on.  To get a
sense of this dependency structure, and inspect a more fine-grained
view of these durations, see
<a href="#interpret-the-html-output">this section</a>.</p>
  </li>
</ul>

<p>These rows are <strong>sorted by total duration</strong>, in descending order.</p>

<h3 id="counts-example-0">Counts: Example 0</h3>

<p>The following example <code class="highlighter-rouge">profile_queries.counts.txt</code> file results from
running on a hello world program (a single main function that uses
<code class="highlighter-rouge">println</code> to print `“hellow world”).</p>

<p>As explained above, the columns consist of <code class="highlighter-rouge">provider/pass</code>, <code class="highlighter-rouge">count</code>, <code class="highlighter-rouge">duration</code>:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>translation,1,0.891
symbol_name,2658,0.733
def_symbol_name,2556,0.268
item_attrs,5566,0.162
type_of,6922,0.117
generics_of,8020,0.084
serialize dep graph,1,0.079
relevant_trait_impls_for,50,0.063
def_span,24875,0.061
expansion,1,0.059
const checking,1,0.055
adt_def,1141,0.048
trait_impls_of,32,0.045
is_copy_raw,47,0.045
is_foreign_item,2638,0.042
fn_sig,2172,0.033
adt_dtorck_constraint,2,0.023
impl_trait_ref,2434,0.023
typeck_tables_of,29,0.022
item-bodies checking,1,0.017
typeck_item_bodies,1,0.017
is_default_impl,2320,0.017
borrow checking,1,0.014
borrowck,4,0.014
mir_validated,4,0.013
adt_destructor,10,0.012
layout_raw,258,0.010
load_dep_graph,1,0.007
item-types checking,1,0.005
mir_const,2,0.005
name resolution,1,0.004
is_object_safe,35,0.003
is_sized_raw,89,0.003
parsing,1,0.003
is_freeze_raw,11,0.001
privacy checking,1,0.001
privacy_access_levels,5,0.001
resolving dependency formats,1,0.001
adt_sized_constraint,9,0.001
wf checking,1,0.001
liveness checking,1,0.001
compute_incremental_hashes_map,1,0.001
match checking,1,0.001
type collecting,1,0.001
param_env,31,0.000
effect checking,1,0.000
trait_def,140,0.000
lowering ast -&gt; hir,1,0.000
predicates_of,70,0.000
extern_crate,319,0.000
lifetime resolution,1,0.000
is_const_fn,6,0.000
intrinsic checking,1,0.000
translation item collection,1,0.000
impl_polarity,15,0.000
creating allocators,1,0.000
language item collection,1,0.000
crate injection,1,0.000
early lint checks,1,0.000
indexing hir,1,0.000
maybe creating a macro crate,1,0.000
coherence checking,1,0.000
optimized_mir,6,0.000
is_panic_runtime,33,0.000
associated_item_def_ids,7,0.000
needs_drop_raw,10,0.000
lint checking,1,0.000
complete gated feature checking,1,0.000
stability index,1,0.000
region_maps,11,0.000
super_predicates_of,8,0.000
coherent_trait,2,0.000
AST validation,1,0.000
loop checking,1,0.000
static item recursion checking,1,0.000
variances_of,11,0.000
associated_item,5,0.000
plugin loading,1,0.000
looking for plugin registrar,1,0.000
stability checking,1,0.000
describe_def,15,0.000
variance testing,1,0.000
codegen unit partitioning,1,0.000
looking for entry point,1,0.000
checking for inline asm in case the target doesn't support it,1,0.000
inherent_impls,1,0.000
crate_inherent_impls,1,0.000
trait_of_item,7,0.000
crate_inherent_impls_overlap_check,1,0.000
attribute checking,1,0.000
internalize symbols,1,0.000
impl wf inference,1,0.000
death checking,1,0.000
reachability checking,1,0.000
reachable_set,1,0.000
is_exported_symbol,3,0.000
is_mir_available,2,0.000
unused lib feature checking,1,0.000
maybe building test harness,1,0.000
recursion limit,1,0.000
write allocator module,1,0.000
assert dep graph,1,0.000
plugin registration,1,0.000
write metadata,1,0.000
</code></pre></div></div>

<h1 id="background">Background</h1>

<p>We give some background about the query model of the Rust compiler.</p>

<h2 id="def-ids">Def IDs</h2>

<p>In the query model, many queries have a key that consists of a Def ID.
The Rust compiler uses Def IDs to distinguish definitions in the input
Rust program.</p>

<p>From the compiler source code (<code class="highlighter-rouge">src/librustc/hir/def_id.rs</code>):</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>/// A DefId identifies a particular *definition*, by combining a crate
/// index and a def index.
#[derive(Clone, Eq, Ord, PartialOrd, PartialEq, RustcEncodable, RustcDecodable, Hash, Copy)]
pub struct DefId {
    pub krate: CrateNum,
    pub index: DefIndex,
}
</code></pre></div></div>

<h2 id="queries">Queries</h2>

<p>A query relates a <em>key</em> to a <em>result</em>, either by invoking a <em>provider</em>
that computes this result, or by reusing a cached result that was
provided earlier.  We explain each term in more detail:</p>

<ul>
  <li>Query <strong>Provider</strong>: Each kind of query has a pre-defined <em>provider</em>,
which refers to the compiler behavior that provides an answer to the
query.  These providers may nest; see <a href="#trace-of-queries">trace of
queries</a> for more information about this nesting structure.    <br />
  <em>Example providers:</em>
    <ul>
      <li><code class="highlighter-rouge">typeck_tables_of</code> – Typecheck a Def ID; produce “tables” of type information.</li>
      <li><code class="highlighter-rouge">borrowck</code> – Borrow-check a Def ID.</li>
      <li><code class="highlighter-rouge">optimized_mir</code> – Generate an optimized MIR for a Def ID; produce MIR.</li>
      <li>For more examples, see <a href="#counts-example-0">Example 0</a>.</li>
    </ul>
  </li>
  <li>Query <strong>Key</strong>: The input/arguments to the provider.  Often, this
consists of a particular <a href="#def-ids">Def ID</a>.</li>
  <li>Query <strong>Result</strong>: The output of the provider.</li>
</ul>

<h2 id="trace-of-queries">Trace of Queries</h2>

<p>Formally, a <em>trace</em> of the queries consists of a <em>tree</em>, where
sub-trees represent sub-traces.  In particular, the nesting structure
of the trace of queries describes how the queries depend on one
another.</p>

<p>Even more precisely, this tree represents a directed acyclic graph
(DAG), where shared sub-graphs consist of tree nodes that occur
multiple times in the tree, first as “cache misses” and later as
“cache hits”.</p>

<p><strong>Cache hits and misses.</strong>
The trace is a tree with the following possible tree nodes:</p>

<ul>
  <li>Query, with cache <strong>miss</strong>: The query’s result is <strong>unknown</strong>, and
its provider runs to compute it.  In this case, the dynamic extent
of the query’s trace consists of the traced behavior of its
provider.</li>
  <li>Query, with cache <strong>hit</strong>: The query’s result is <strong>known</strong>, and is
reused; its provider does not rerun.  These nodes are leaves in the
trace, since they have no dynamic extent.  These leaves also
represent where the tree, represented as a DAG, would <em>share</em> a
sub-graph (namely, the sub-graph of the query that was reused from
the cache).</li>
</ul>

<p><strong>Tree node metrics.</strong>
To help determine how to style this tree, we define the following tree
node metrics:</p>

<ul>
  <li><strong>Depth</strong>: The number of <strong>ancestors</strong> of the node in its path from the tree root.</li>
  <li><strong>Extent</strong>: The number of <strong>immediate children</strong> of the node.</li>
</ul>

<p>Intuitively, a dependency tree is “good” for incremental caching when
the depth and extent of each node is relatively small.  It is
pathological when either of these metrics grows too large.  For
instance, a tree node whose extent consists of 1M immediate children
means that if and when this node is re-computed, all 1M children must
be re-queried, at the very least (some may also require recomputation,
too).</p>

<h2 id="links">Links</h2>

<p>Related design ideas, and tracking issues:</p>

<ul>
  <li>Design document: <a href="https://github.com/nikomatsakis/rustc-on-demand-incremental-design-doc/blob/master/0000-rustc-on-demand-and-incremental.md">On-demand Rustc incremental design doc</a></li>
  <li>Tracking Issue: <a href="https://github.com/rust-lang/rust/issues/42293">“Red/Green” dependency tracking in compiler</a></li>
</ul>

<p>More discussion and issues:</p>

<ul>
  <li>https://github.com/rust-lang/rust/issues/42633</li>
  <li>https://internals.rust-lang.org/t/incremental-compilation-beta/4721</li>
  <li>https://blog.rust-lang.org/2016/09/08/incremental.html</li>
</ul>
</div>

  </body>
</html>
